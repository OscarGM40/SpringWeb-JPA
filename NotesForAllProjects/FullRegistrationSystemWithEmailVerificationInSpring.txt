		COMPLETE USER LOGIN AND REGISTRATION BACKEND WITH EMAIL VERIFICATION

Source: https://www.youtube.com/watch?v=QwQuro7ekvc&ab_channel=Amigoscode

Usaremos PostGreSQL como Db,bcrypt para encriptar la password.Empecemos.Voy a Spring Initizalzr y eligo como dependencias: lombok,spring web,spring security,spring data jpa,postgresql driver y java mail sender.

Fijate que el driver cambia al usar PostGreSQL y que ya tienen una dependencia para envio de emails.

NOTA:fijate que Spring tiene dependencias para WebSockets,para MOngoDB,ApacheCassandra,CouchDB,investigar que es Batch también.

IMPORANTE:fijate que puedo generar un link para compartir con el starter-project
(https://start.spring.io/#!type=maven-project&language=java&platformVersion=2.6.3&packaging=jar&jvmVersion=11&groupId=com.example&artifactId=demo&name=demo&description=Demo%20project%20for%20Spring%20Boot&packageName=com.example.demo&dependencies=lombok,web,security,postgresql,data-jpa,mail)
Increible

Fijate,estas dos dependencias son para testing:
	<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-test</artifactId>
		<scope>test</scope>
	</dependency>
	<dependency>
		<groupId>org.springframework.security</groupId>
		<artifactId>spring-security-test</artifactId>
		<scope>test</scope>
	
Sigo con la conexión a PostGreSQL,usaré mi contenedor.Recuerda |d+ table_name para ver las columnas.Aparte hay que cambiar el driver,el dialecto y la cadena de conexión,lógicamente:

spring.datasource.driver-class-name=org.postgresql.Driver
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

NOTA:fijate que él ha renombrado el application.properties a application.yaml y usado sintaxis yaml,claro.¿Hay algún beneficio en esto?.

						EMPEZANDO CON LA LÓGICA

Fijate que lo primero que ha hecho ha sido crear una clase que va a implementar la interfaz UserDetails ,y además necesitaremos una enum para la propiedad que albergará los roles:

public class AppUser implements UserDetails {

  private Long id;
  private String name;
  private String username;
  private String email;
  private String password;

  @Enumerated(EnumType.STRING)
  private AppUserRole appUserRole; <- AppUserRole será una enum,recuerda que una enum debe ser anotada con su tipo de dato en Spring

package com.example.demo.appuser;

public enum AppUserRole {
  USER, ADMIN
}
También necesitare un par de propiedades más:
private Boolean locked;
private Boolean enabled;

IMPORTANTE:para acceder al nombre de esa enum Java ya me proporciona el método name():
  SimpleGrantedAuthority authority = new SimpleGrantedAuthority(appUserRole.name()); <- name es buil-in method

Con todo esto retorno una lista inmutable:
return Collections.singletonList(authority);
Sobreescribo los demás métodos de la interfaz UserDetails:

  @Override
  public String getPassword() {
    return password;
  }

  @Override
  public String getUsername() {
    return username;
  }

  @Override
  public boolean isAccountNonExpired() {
    return true;
  }

  @Override
  public boolean isAccountNonLocked() {
    return !locked;
  }

  @Override
  public boolean isCredentialsNonExpired() {
    return true;
  }

  @Override
  public boolean isEnabled() {
    return enabled;
  }

IMPORTANTE:la clase realmente va aser anotada con @Entity,y fijate como genera el id(es porque es postgresql??).Necesitó del decorador @SequenceGenerator:
 @Id 
  @SequenceGenerator(
    name="student_sequence",
    sequenceName = "student_sequence",
    allocationSize = 1
  )
  @GeneratedValue(
    strategy= GenerationType.SEQUENCE,
    generator= "student_sequence"
  )
  private Long id;

Bien,creo otra clase y esta vez implementará la interfaz UserDetailsService.Recuerda que está interfaz explica a Spring cómo debe de cargar un usuario,mientras que la anterior especific cómo luce un usuario.

public class AppUserService implements UserDetailsService {

  @Override
  public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    return null;
  }
  
}

* En esta aplicación vamos a cargar por email,asi que necesitamos antes que nada una forma de cargar users por email.Asi que creo una interfaz de esta forma:

import org.springframework.transaction.annotation.Transactional;

@Repository
@Transactional(readOnly = true)
public interface StudentRepository {
  Optional<AppUser> findByEmail(String email);
}

Bien,este método va a buscar por el email(debo entender porqué).Asi que ya puedo llamarlo y devolverle a la implementación del loadUserByUsername de la interfaz UserDetailsService lo correcto:

@Service
@AllArgsConstructor
public class AppUserService implements UserDetailsService {

  private final AppUserRepository appUserRepository;
  private final static String EMAIL_NOT_FOUND="User with this email (%s) not found in our database.Consider registering first";
  
  @Override
  public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
    return appUserRepository
      .findByEmail(email)
      .orElseThrow(() -> new UsernameNotFoundException(
        String.format(EMAIL_NOT_FOUND, email)));
  }


						CONFIGURATING SECURITY

Esta vez vamos a crear la seguridad distribuida un tanto diferente.No es importante.Simplemente desactivamos la seguridad para el register:

@Configuration  
@EnableWebSecurity
@AllArgsConstructor
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {@Override

  protected void configure(HttpSecurity http) throws Exception {
    /* desactivo su seguridad temporalmente*/
    http
      .csrf().disable()
      .authorizeRequests()
      .antMatchers( HttpMethod.POST,"/api/v*/registration/**")
      .permitAll()
      .anyRequest()
      .authenticated().and()
      .formLogin();
  }

IMPORTANTE: fijate como vamos a configurar el AuthenticationManager para la autorización,creando un Bean para la clase DaoAuthenticationProvider,la cual proveerá el codificador y la clase userDetailsService.Desde luego hay varias formas,si:

@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
  auth.authenticationProvider(daoAuthenticationProvider());
}

@Bean
public DaoAuthenticationProvider daoAuthenticationProvider(){
  DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
  provider.setPasswordEncoder(bCryptPasswordEncoder);
  provider.setUserDetailsService(appUserService);
  return provider;
}

IMPORTANTE:no encontraba el Bean de AppUserRepository porque la interfaz necesitaba heredar de la abstracta JpaRepository,no por otra cosa.
Y lo mismo para RegistrationService.

/* fijate que tuvimos que anotarla con configuration */
@Configuration
public class PasswordEncoder {

  /* fijate que @Bean es sólo para el interior de las clases,en este caso un método */
  @Bean
  public BCryptPasswordEncoder bCryptPasswordEncoder() {
    return new BCryptPasswordEncoder();
  }
    
}
Importante:fijate que este proyecto es un poco más complejo,pero al loadUserByUsername lo llamé en AppUserService,que con ayuda del repo que extiende de Jpa me lo carga por email.Son varias cosas pero no es complejo.




					LOGICA PARA REGISTRAR UN USUARIO
