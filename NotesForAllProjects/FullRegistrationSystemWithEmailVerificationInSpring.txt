		COMPLETE USER LOGIN AND REGISTRATION BACKEND WITH EMAIL VERIFICATION

Source: https://www.youtube.com/watch?v=QwQuro7ekvc&ab_channel=Amigoscode

Usaremos PostGreSQL como Db,bcrypt para encriptar la password.Empecemos.Voy a Spring Initizalzr y eligo como dependencias: lombok,spring web,spring security,spring data jpa,postgresql driver y java mail sender.

Fijate que el driver cambia al usar PostGreSQL y que ya tienen una dependencia para envio de emails.

NOTA:fijate que Spring tiene dependencias para WebSockets,para MOngoDB,ApacheCassandra,CouchDB,investigar que es Batch también.

IMPORANTE:fijate que puedo generar un link para compartir con el starter-project
(https://start.spring.io/#!type=maven-project&language=java&platformVersion=2.6.3&packaging=jar&jvmVersion=11&groupId=com.example&artifactId=demo&name=demo&description=Demo%20project%20for%20Spring%20Boot&packageName=com.example.demo&dependencies=lombok,web,security,postgresql,data-jpa,mail)
Increible

Fijate,estas dos dependencias son para testing:
	<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-test</artifactId>
		<scope>test</scope>
	</dependency>
	<dependency>
		<groupId>org.springframework.security</groupId>
		<artifactId>spring-security-test</artifactId>
		<scope>test</scope>
	
Sigo con la conexión a PostGreSQL,usaré mi contenedor.Recuerda |d+ table_name para ver las columnas.Aparte hay que cambiar el driver,el dialecto y la cadena de conexión,lógicamente:

spring.datasource.driver-class-name=org.postgresql.Driver
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

NOTA:fijate que él ha renombrado el application.properties a application.yaml y usado sintaxis yaml,claro.¿Hay algún beneficio en esto?.

						EMPEZANDO CON LA LÓGICA

Fijate que lo primero que ha hecho ha sido crear una clase que va a implementar la interfaz UserDetails ,y además necesitaremos una enum para la propiedad que albergará los roles:

public class AppUser implements UserDetails {

  private Long id;
  private String name;
  private String username;
  private String email;
  private String password;

  @Enumerated(EnumType.STRING)
  private AppUserRole appUserRole; <- AppUserRole será una enum,recuerda que una enum debe ser anotada con su tipo de dato en Spring

package com.example.demo.appuser;

public enum AppUserRole {
  USER, ADMIN
}
También necesitare un par de propiedades más:
private Boolean locked;
private Boolean enabled;

IMPORTANTE:para acceder al nombre de esa enum Java ya me proporciona el método name():
  SimpleGrantedAuthority authority = new SimpleGrantedAuthority(appUserRole.name()); <- name es buil-in method

Con todo esto retorno una lista inmutable:
return Collections.singletonList(authority);
Sobreescribo los demás métodos de la interfaz UserDetails:

  @Override
  public String getPassword() {
    return password;
  }

  @Override
  public String getUsername() {
    return username;
  }

  @Override
  public boolean isAccountNonExpired() {
    return true;
  }

  @Override
  public boolean isAccountNonLocked() {
    return !locked;
  }

  @Override
  public boolean isCredentialsNonExpired() {
    return true;
  }

  @Override
  public boolean isEnabled() {
    return enabled;
  }

IMPORTANTE:la clase realmente va aser anotada con @Entity,y fijate como genera el id(es porque es postgresql??).Necesitó del decorador @SequenceGenerator:
 @Id 
  @SequenceGenerator(
    name="student_sequence",
    sequenceName = "student_sequence",
    allocationSize = 1
  )
  @GeneratedValue(
    strategy= GenerationType.SEQUENCE,
    generator= "student_sequence"
  )
  private Long id;

Bien,creo otra clase y esta vez implementará la interfaz UserDetailsService.Recuerda que está interfaz explica a Spring cómo debe de cargar un usuario,mientras que la anterior especific cómo luce un usuario.

public class AppUserService implements UserDetailsService {

  @Override
  public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    return null;
  }
  
}

* En esta aplicación vamos a cargar por email,asi que necesitamos antes que nada una forma de cargar users por email.Asi que creo una interfaz de esta forma:

import org.springframework.transaction.annotation.Transactional;

@Repository
@Transactional(readOnly = true)
public interface StudentRepository {
  Optional<AppUser> findByEmail(String email);
}

Bien,este método va a buscar por el email(debo entender porqué).Asi que ya puedo llamarlo y devolverle a la implementación del loadUserByUsername de la interfaz UserDetailsService lo correcto:

@Service
@AllArgsConstructor
public class AppUserService implements UserDetailsService {

  private final AppUserRepository appUserRepository;
  private final static String EMAIL_NOT_FOUND="User with this email (%s) not found in our database.Consider registering first";
  
  @Override
  public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
    return appUserRepository
      .findByEmail(email)
      .orElseThrow(() -> new UsernameNotFoundException(
        String.format(EMAIL_NOT_FOUND, email)));
  }


						CONFIGURATING SECURITY

Esta vez vamos a crear la seguridad distribuida un tanto diferente.No es importante.Simplemente desactivamos la seguridad para el register:

@Configuration  
@EnableWebSecurity
@AllArgsConstructor
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {@Override

  protected void configure(HttpSecurity http) throws Exception {
    /* desactivo su seguridad temporalmente*/
    http
      .csrf().disable()
      .authorizeRequests()
      .antMatchers( HttpMethod.POST,"/api/v*/registration/**")
      .permitAll()
      .anyRequest()
      .authenticated().and()
      .formLogin();
  }

IMPORTANTE: fijate como vamos a configurar el AuthenticationManager para la autorización,creando un Bean para la clase DaoAuthenticationProvider,la cual proveerá el codificador y la clase userDetailsService.Desde luego hay varias formas,si:

@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
  auth.authenticationProvider(daoAuthenticationProvider());
}

@Bean
public DaoAuthenticationProvider daoAuthenticationProvider(){
  DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
  provider.setPasswordEncoder(bCryptPasswordEncoder);
  provider.setUserDetailsService(appUserService);
  return provider;
}

IMPORTANTE:no encontraba el Bean de AppUserRepository porque la interfaz necesitaba heredar de la abstracta JpaRepository,no por otra cosa.
Y lo mismo para RegistrationService.

/* fijate que tuvimos que anotarla con configuration */
@Configuration
public class PasswordEncoder {

  /* fijate que @Bean es sólo para el interior de las clases,en este caso un método */
  @Bean
  public BCryptPasswordEncoder bCryptPasswordEncoder() {
    return new BCryptPasswordEncoder();
  }
    
}
Importante:fijate que este proyecto es un poco más complejo,pero al loadUserByUsername lo llamé en AppUserService,que con ayuda del repo que extiende de Jpa me lo carga por email.Son varias cosas pero no es complejo.

					LOGICA PARA REGISTRAR UN USUARIO

Playing around: jugando con ello,jugando por ahí,...
Bien,vamos a crearnos una clase helper para checkear el campo email.Será una clase que implemente la interfaz Predicate<T> y desarrolle su método test(String t):boolean.
Fijate que T será el tipo de lo que quiero chequear,en este caso será el valor que traiga el <input type=email> asi que será Predicate<String>:

@Service
public class EmailValidator implements Predicate<String> {
  @Override
  public boolean test(String){
    return t.contains("@");
  }
}
Obviamente irá una regexp aqui más complicada.
Bien,asinto fijate que \x es una opción básica para la consola de PostGreSQL.Activa o desactiva el expanded display.
NOTA:fijate que tuvo algún que otro fallo.Nos olvidamos poner valores por defecto para locked y enabled:

 private Boolean locked=false;
 private Boolean enabled=false;

Solamente activaremos la cuenta tras el email de confirmación,obviamente.Fijate que Java tiene un sistema de registro bastante robusto por defecto.

Bien,ya es hora de registrar un User,simplemente el controlador que llame a un método de un Service que lo guarde con ayuda del reposiorio:
 @PostMapping
  public String register(@RequestBody RegistrationRequest request) {
    return registrationService.register(request);
  }

Ese register llama a éste,que está en un @Service.No sé porque creó dos,con uno quizas hubiera sido mejor??:

  public String register(RegistrationRequest request) {
    boolean isValidEmail = emailValidator.test(request.getEmail());
    if (!isValidEmail) {
      throw new IllegalStateException("Invalid email address");
    }
    return appUserService.signUpUser(
      new AppUser(
        request.getFirstName(),
        request.getLastName(),
        request.getEmail(),
        request.getPassword(), 
        AppUserRole.USER
        )
    );
  }

Sea como sea,ese signUpUser del otro @Service AppUserService luce así:

  public String signUpUser(AppUser appUser) {
     boolean userExists = appUserRepository.findByEmail(appUser.getEmail()).isPresent();
    
    if (userExists) {
      throw new IllegalStateException("User with this email (" + appUser.getEmail() + ") already exists");
    }
    String encodedPass = bCryptPasswordEncoder.encode(appUser.getPassword());    
    appUser.setPassword(encodedPass);
    /* recuerda guardarlo a la DB mediante el repository */
    appUserRepository.save(appUser);
    // TODO : send confirmation token
    return "User registered successfully";
  }

Fijate que hay que comprobar la uniqueness del email,encriptar la password y guardar el user.En este punto ya puedo guardar un User,e incluso ir a localhost:8080/login y tratar de hacer signIn,pero no podré porque la cuenta está disabled.Fijate es por querer implementar esta opción por lo que tuvimos que imlementar UserDetails y sobreescribir todos sus métodos,pero ahora ya veo los beneficios.

				IMPLEMENTING VERIFICATION LINK AND SENDING EMAILS

Vamos a crear una Entity para el token,ya que tiene bastantes features.Fijate en el uso de LocalDateTime para el issuedAt,expiresAt o confirmedAt:

@Entity @Getter @Setter @NoArgsConstructor
public class ConfirmationToken {

  @Id
  @SequenceGenerator(name = "confirmation_token_sequence", sequenceName = "confirmation_token_sequence", allocationSize = 1)
  @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "confirmation_token_sequence")
  private Long id;
  
 @Column(nullable=false)
  private String token;

  @Column(nullable=false)
  private LocalDateTime issuedAt;

  @Column(nullable=false)
  private LocalDateTime expiresAt;
  private LocalDateTime confirmedAt;

  public ConfirmationToken(String token,
      LocalDateTime issuedAt,
      LocalDateTime expiresAt,
      LocalDateTime confirmedAt) {
    this.token = token;
    this.issuedAt = issuedAt;
    this.expiresAt = expiresAt;
    this.confirmedAt = confirmedAt;
  }
Además,casi todas las columnas no pueden ser nulas por motivos obvios.
1h08m
